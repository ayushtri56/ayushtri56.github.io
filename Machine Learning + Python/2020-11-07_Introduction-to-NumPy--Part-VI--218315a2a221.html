<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Introduction to NumPy (Part VI)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Introduction to NumPy (Part VI)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Before we start, I would like to ask the reader to look out on Jupyter notebook which we will be using throughout the upcoming articles.
</section>
<section data-field="body" class="e-content">
<section name="9a7e" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c852" id="c852" class="graf graf--h3 graf--leading graf--title">Introduction to NumPy (Part VI)</h3><p name="f104" id="f104" class="graf graf--p graf-after--h3">Before we start, I would like to ask the reader to look out on<strong class="markup--strong markup--p-strong"> Jupyter notebook</strong> which we will be using throughout the upcoming articles.</p><blockquote name="d0b1" id="d0b1" class="graf graf--pullquote graf-after--p">Install the<a href="https://jupyter.org" data-href="https://jupyter.org" class="markup--anchor markup--pullquote-anchor" rel="noopener" target="_blank"> Jupyter notebook</a><strong class="markup--strong markup--pullquote-strong"><em class="markup--em markup--pullquote-em"> (Prerequisite)</em></strong></blockquote><ol class="postList"><li name="d286" id="d286" class="graf graf--li graf-after--pullquote">Start new or upload an existing notebook, and utilize markup features.</li><li name="89bb" id="89bb" class="graf graf--li graf-after--li">Get acquainted with the keyboard shortcuts and magic keywords.</li><li name="9438" id="9438" class="graf graf--li graf-after--li">Converting notebooks to other file formats.</li></ol><p name="5017" id="5017" class="graf graf--p graf-after--li">Previous article: <a href="https://nishantnitb.medium.com/python-packages-for-data-science-part-v-b3e519dc78df?source=your_stories_page-------------------------------------" data-href="https://nishantnitb.medium.com/python-packages-for-data-science-part-v-b3e519dc78df?source=your_stories_page-------------------------------------" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Python packages for Data Science (Part V)</a></p><blockquote name="1893" id="1893" class="graf graf--blockquote graf-after--p"><strong class="markup--strong markup--blockquote-strong">Note</strong>: Use Jupyter notebook to run below codes, always <strong class="markup--strong markup--blockquote-strong">import numpy as np</strong></blockquote><figure name="4011" id="4011" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*AtzWn05UpL_8WK4-Byfr3A.png" data-width="904" data-height="368" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*AtzWn05UpL_8WK4-Byfr3A.png"></figure><h3 name="c09e" id="c09e" class="graf graf--h3 graf-after--figure">What is NumPy?</h3><p name="2bb8" id="2bb8" class="graf graf--p graf-after--h3">NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</p><p name="ea1e" id="ea1e" class="graf graf--p graf-after--p">At the core of the NumPy package, is the <em class="markup--em markup--p-em">ndarray</em> object. This encapsulates <em class="markup--em markup--p-em">n</em>-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</p><ul class="postList"><li name="85a5" id="85a5" class="graf graf--li graf-after--p">NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an <em class="markup--em markup--li-em">ndarray</em> will create a new array and delete the original.</li><li name="09aa" id="09aa" class="graf graf--li graf-after--li">The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</li><li name="0133" id="0133" class="graf graf--li graf-after--li">NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python’s built-in sequences.</li><li name="670e" id="670e" class="graf graf--li graf-after--li">A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays. In other words, in order to efficiently use much (perhaps even most) of today’s scientific/mathematical Python-based software, just knowing how to use Python’s built-in sequence types is insufficient — one also needs to know how to use NumPy arrays.</li></ul><h3 name="0de6" id="0de6" class="graf graf--h3 graf-after--li">The Basics</h3><p name="7c99" id="7c99" class="graf graf--p graf-after--h3">NumPy’s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called <em class="markup--em markup--p-em">axes</em>.</p><p name="39cb" id="39cb" class="graf graf--p graf-after--p">For example, the coordinates of a point in 3D space <code class="markup--code markup--p-code">[1, 2, 1]</code> has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3.</p><pre name="8f0d" id="8f0d" class="graf graf--pre graf-after--p">[[ 1., 0., 0.],<br> [ 0., 1., 2.]]</pre><p name="5dfb" id="5dfb" class="graf graf--p graf-after--pre">NumPy’s array class is called <code class="markup--code markup--p-code">ndarray</code>. It is also known by the alias <code class="markup--code markup--p-code">array</code>. Note that <code class="markup--code markup--p-code">numpy.array</code> is not the same as the Standard Python Library class <code class="markup--code markup--p-code">array.array</code>, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an <code class="markup--code markup--p-code">ndarray</code> object are:</p><p name="5a3e" id="5a3e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.ndim</strong></p><p name="e56a" id="e56a" class="graf graf--p graf-after--p">the number of axes (dimensions) of the array.</p><p name="a55d" id="a55d" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.shape</strong></p><p name="c821" id="c821" class="graf graf--p graf-after--p">the dimensions of the array. This is a tuple of integers indicating the size of the array in each dimension. For a matrix with <em class="markup--em markup--p-em">n</em>rows and <em class="markup--em markup--p-em">m</em> columns, <code class="markup--code markup--p-code">shape</code> will be <code class="markup--code markup--p-code">(n,m)</code>. The length of the <code class="markup--code markup--p-code">shape</code> tuple is therefore the number of axes, <code class="markup--code markup--p-code">ndim</code>.</p><p name="5855" id="5855" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.size</strong></p><p name="1fef" id="1fef" class="graf graf--p graf-after--p">the total number of elements of the array. This is equal to the product of the elements of <code class="markup--code markup--p-code">shape</code>.</p><p name="ee23" id="ee23" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.dtype</strong></p><p name="27e1" id="27e1" class="graf graf--p graf-after--p">an object describing the type of the elements in the array. One can create or specify dtype’s using standard Python types. Additionally NumPy provides types of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples.</p><p name="071e" id="071e" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.itemsize</strong></p><p name="f74d" id="f74d" class="graf graf--p graf-after--p">the size in bytes of each element of the array. For example, an array of elements of type <code class="markup--code markup--p-code">float64</code> has <code class="markup--code markup--p-code">itemsize</code> 8 (=64/8), while one of type <code class="markup--code markup--p-code">complex32</code> has <code class="markup--code markup--p-code">itemsize</code> 4 (=32/8). It is equivalent to <code class="markup--code markup--p-code">ndarray.dtype.itemsize</code>.</p><p name="77d7" id="77d7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">ndarray.data</strong></p><p name="fa17" id="fa17" class="graf graf--p graf-after--p">the buffer containing the actual elements of the array. Normally, we won’t need to use this attribute because we will access the elements in an array using indexing facilities.</p><pre name="6f62" id="6f62" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 1D ndarray that contains only integers</em><br>x = np.array([1, 2, 3, 4, 5])<br><br><em class="markup--em markup--pre-em"># We print information about x</em><br>print(&#39;x = &#39;, x)<br>print(&#39;x has dimensions:&#39;, x.shape)<br>print(&#39;x is an object of type:&#39;, type(x))<br>print(&#39;The elements in x are of type:&#39;, x.dtype)</code></pre><blockquote name="4711" id="4711" class="graf graf--blockquote graf-after--pre">x = [1 2 3 4 5]</blockquote><blockquote name="c80c" id="c80c" class="graf graf--blockquote graf-after--blockquote">x has dimensions: (5,)<br>x is an object of type: class ‘numpy.ndarray’<br>The elements in x are of type: int64</blockquote><blockquote name="c7b3" id="c7b3" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">Note</strong>: Use Jupyter notebook to run below codes, always <strong class="markup--strong markup--blockquote-strong">import numpy as np</strong></blockquote><h4 name="6f34" id="6f34" class="graf graf--h4 graf-after--blockquote">Additional Resource</h4><ul class="postList"><li name="aa16" id="aa16" class="graf graf--li graf-after--h4">Refer more example at <a href="https://numpy.org/devdocs/user/absolute_beginners.html#how-to-create-a-basic-array" data-href="https://numpy.org/devdocs/user/absolute_beginners.html#how-to-create-a-basic-array" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">NumPy.org — How to create a basic array</a></li></ul><h3 name="862b" id="862b" class="graf graf--h3 graf-after--li">Creating and Saving NumPy ndarrays</h3><p name="9ef6" id="9ef6" class="graf graf--p graf-after--h3">Any data saved to the file is appended to the end of the file.</p><p name="9257" id="9257" class="graf graf--p graf-after--p">Examples</p><pre name="571f" id="571f" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; import</strong> <strong class="markup--strong markup--pre-strong">numpy</strong> <strong class="markup--strong markup--pre-strong">as</strong> <strong class="markup--strong markup--pre-strong">np</strong><br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>a = np.array([2,3,4])<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>a<br>array([2, 3, 4])<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>a.dtype<br>dtype(&#39;int64&#39;)<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>b = np.array([1.2, 3.5, 5.1])<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>b.dtype<br>dtype(&#39;float64&#39;)</pre><pre name="951b" id="951b" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong"><br>&gt;&gt;&gt; from</strong> <strong class="markup--strong markup--pre-strong">tempfile</strong> <strong class="markup--strong markup--pre-strong">import</strong> TemporaryFile<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>outfile = TemporaryFile()</pre><pre name="d2bd" id="d2bd" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>x = np.arange(10)<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>np.save(outfile, x)</pre><pre name="8764" id="8764" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>_ = outfile.seek(0) <em class="markup--em markup--pre-em"># Only needed here to simulate closing &amp; reopening file</em><br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>np.load(outfile)<br>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</pre><pre name="b842" id="b842" class="graf graf--pre graf-after--pre"><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; with</strong> open(&#39;test.npy&#39;, &#39;wb&#39;) <strong class="markup--strong markup--pre-strong">as</strong> f:<br><strong class="markup--strong markup--pre-strong">... </strong>    np.save(f, np.array([1, 2]))<br><strong class="markup--strong markup--pre-strong">... </strong>    np.save(f, np.array([1, 3]))<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; with</strong> open(&#39;test.npy&#39;, &#39;rb&#39;) <strong class="markup--strong markup--pre-strong">as</strong> f:<br><strong class="markup--strong markup--pre-strong">... </strong>    a = np.load(f)<br><strong class="markup--strong markup--pre-strong">... </strong>    b = np.load(f)<br><strong class="markup--strong markup--pre-strong">&gt;&gt;&gt; </strong>print(a, b)<br># [1 2] [1 3]</pre><h3 name="cab7" id="cab7" class="graf graf--h3 graf-after--pre">Using Built-in Functions to Create ndarrays</h3><p name="6ae3" id="6ae3" class="graf graf--p graf-after--h3">NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation. For example: np.zeros,np.empty etc.</p><pre name="757d" id="757d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 3 x 4 ndarray full of zeros. </em><br>X = np.zeros((3,4))<br><br><em class="markup--em markup--pre-em"># We print X</em><br>print()<br>print(&#39;X = \n&#39;, X)<br>print()<br><br><em class="markup--em markup--pre-em"># We print information about X</em><br>print(&#39;X has dimensions:&#39;, X.shape)<br>print(&#39;X is an object of type:&#39;, type(X))<br>print(&#39;The elements in X are of type:&#39;, X.dtype)</code></pre><blockquote name="7adb" id="7adb" class="graf graf--blockquote graf-after--pre">X =<br>[[ 0. 0. 0. 0.]<br> [ 0. 0. 0. 0.]<br> [ 0. 0. 0. 0.]]</blockquote><blockquote name="321d" id="321d" class="graf graf--blockquote graf-after--blockquote">X has dimensions: (3, 4)<br>X is an object of type: class &#39;numpy.ndarray&#39;<br>The elements in X are of type: float64</blockquote><p name="d53e" id="d53e" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Create a Numpy array of ones</strong></p><pre name="5777" id="5777" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 3 x 2 ndarray full of ones. </em><br>X = np.ones((3,2))</code></pre><blockquote name="d87c" id="d87c" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note</strong>: Use Jupyter notebook to run below codes, always <strong class="markup--strong markup--blockquote-strong">import numpy as np</strong></blockquote><p name="21b5" id="21b5" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Create a Numpy array of constants</strong></p><pre name="3db8" id="3db8" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 2 x 3 ndarray full of fives. </em><br>X = np.full((2,3), 5)</code></pre><p name="0961" id="0961" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array of an Identity matrix</strong></p><pre name="2f21" id="2f21" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 5 x 5 Identity matrix. </em><br>X = np.eye(5)</code></pre><p name="ae98" id="ae98" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">X =<br>[[ 1. 0. 0. 0. 0.]<br> [ 0. 1. 0. 0. 0.]<br> [ 0. 0. 1. 0. 0.]<br> [ 0. 0. 0. 1. 0.]<br> [ 0. 0. 0. 0. 1.]]</em></p><p name="6ca7" id="6ca7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Create a Numpy array of constants</strong></p><pre name="be8d" id="be8d" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># Create a 4 x 4 diagonal matrix that contains the numbers 10,20,30, and 50</em><br><em class="markup--em markup--pre-em"># on its main diagonal</em><br>X = np.diag([10,20,30,50])</code></pre><p name="f32c" id="f32c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array of evenly spaced values in a given range</strong>, using <code class="markup--code markup--p-code">arange(stop_val)</code></p><pre name="f112" id="f112" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray that has sequential integers from 0 to 9</em><br>x = np.arange(10)</code></pre><p name="c9de" id="c9de" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array using </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">arange(start_val, stop_val)</strong></code></p><pre name="f841" id="f841" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray that has sequential integers from 4 to 9. </em><br>x = np.arange(4,10)</code></pre><p name="f9e3" id="f9e3" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array using </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">arange(start_val, stop_val, step_size)</strong></code></p><pre name="3b96" id="3b96" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray that has evenly spaced integers from 1 to 13 in steps of 3.</em><br>x = np.arange(1,14,3)</code></pre><p name="53e9" id="53e9" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array using </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">linspace(start, stop, n)</strong></code><strong class="markup--strong markup--p-strong">, with </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">stop</strong></code><strong class="markup--strong markup--p-strong"> inclusive.</strong></p><pre name="1ecd" id="1ecd" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray that has 10 integers evenly spaced between 0 and 25.</em><br>x = np.linspace(0,25,10)</code></pre><p name="3a40" id="3a40" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array using </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">linspace(start, stop, n)</strong></code><strong class="markup--strong markup--p-strong">, with </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">stop</strong></code><strong class="markup--strong markup--p-strong"> excluded.</strong></p><pre name="7f0b" id="7f0b" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray that has 10 integers evenly spaced between 0 and 25,</em><br><em class="markup--em markup--pre-em"># with 25 excluded.</em><br>x = np.linspace(0,25,10, endpoint = False)</code></pre><p name="5490" id="5490" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array by feeding the output of </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">arange()</strong></code><strong class="markup--strong markup--p-strong"> function as an argument to the </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">reshape()</strong></code><strong class="markup--strong markup--p-strong"> function.</strong></p><pre name="4ada" id="4ada" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray with sequential integers from 0 to 19</em><br>x = np.arange(20)<br><em class="markup--em markup--pre-em"># We reshape x into a 4 x 5 ndarray </em><br>x = np.reshape(x, (4,5))</code></pre><blockquote name="4c84" id="4c84" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note</strong>: Use Jupyter notebook to run below codes, always <strong class="markup--strong markup--blockquote-strong">import numpy as np</strong></blockquote><p name="8ca1" id="8ca1" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Create a rank 2 Numpy array by using the </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">reshape()</strong></code><strong class="markup--strong markup--p-strong"> function.</strong></p><pre name="e3dc" id="e3dc" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray with 10 integers evenly spaced between 0 and 50,</em><br><em class="markup--em markup--pre-em"># with 50 excluded. We then reshape it to a 5 x 2 ndarray</em><br>X = np.linspace(0,50,10, endpoint=False).reshape(5,2)</code></pre><blockquote name="7813" id="7813" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">X =<br> [[ 0. 5.]<br> [ 10. 15.]<br> [ 20. 25.]<br> [ 30. 35.]<br> [ 40. 45.]]</em></blockquote><p name="e99a" id="e99a" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Create a Numpy array using the </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">numpy.random.random()</strong></code><strong class="markup--strong markup--p-strong"> function.</strong></p><pre name="8155" id="8155" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 3 x 3 ndarray with random floats in the half-open interval [0.0, 1.0).</em><br>X = np.random.random((3,3))</code></pre><p name="47bc" id="47bc" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Create a Numpy array of “Normal” distributed random numbers, using the </strong><code class="markup--code markup--p-code"><strong class="markup--strong markup--p-strong">numpy.random.normal()</strong></code><strong class="markup--strong markup--p-strong"> function.</strong></p><pre name="a240" id="a240" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 1000 x 1000 ndarray of random floats drawn from normal (Gaussian) distribution</em><br><em class="markup--em markup--pre-em"># with a mean of zero and a standard deviation of 0.1.</em><br>X = np.random.normal(0, 0.1, size=(1000,1000))</code></pre><h3 name="1209" id="1209" class="graf graf--h3 graf-after--pre">Accessing, Deleting, and Inserting Elements Into ndarrays</h3><p name="1c79" id="1c79" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">Access individual elements of 2-D array</strong></p><pre name="c6b9" id="c6b9" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 3 x 3 rank 2 ndarray that contains integers from 1 to 9</em><br>X = np.array([[1,2,3],[4,5,6],[7,8,9]])</code></pre><pre name="8c2f" id="8c2f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We print X</em><br>print()<br>print(&#39;X = \n&#39;, X)<br>print()</code></pre><pre name="61c4" id="61c4" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># Let&#39;s access some elements in X</em><br>print(&#39;This is (0,0) Element in X:&#39;, X[0,0])<br>print(&#39;This is (0,1) Element in X:&#39;, X[0,1])<br>print(&#39;This is (2,2) Element in X:&#39;, X[2,2])</code></pre><p name="0b88" id="0b88" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Modify an element of 2-D array</strong></p><pre name="2173" id="2173" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We change the (0,0) element in X from 1 to 20</em><br>X[0,0] = 20</code></pre><p name="12ae" id="12ae" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Delete elements</strong></p><pre name="6143" id="6143" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 2 ndarray </em><br>Y = np.array([[1,2,3],[4,5,6]])</code></pre><pre name="5de0" id="5de0" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We delete the first row of y</em><br>w = np.delete(Y, 0, axis=0)<br><br><em class="markup--em markup--pre-em"># We delete the first and last column of y</em><br>v = np.delete(Y, [0,2], axis=1)</code></pre><p name="126b" id="126b" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Append elements</strong></p><pre name="fdf5" id="fdf5" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 2 ndarray </em><br>Y = np.array([[1,2,3],[4,5,6]])</code></pre><pre name="4493" id="4493" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We append a new row containing 7,8,9 to y</em><br>v = np.append(Y, [[7,8,9]], axis=0)<br><br><em class="markup--em markup--pre-em"># We append a new column containing 9 and 10 to y</em><br>q = np.append(Y,[[9],[10]], axis=1)</code></pre><h4 name="d8ec" id="d8ec" class="graf graf--h4 graf-after--pre">Stack arrays</h4><pre name="8125" id="8125" class="graf graf--pre graf-after--h4"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray </em><br>x = np.array([1,2])<br><br><em class="markup--em markup--pre-em"># We create a rank 2 ndarray </em><br>Y = np.array([[3,4],[5,6]])</code></pre><pre name="eaed" id="eaed" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We stack x on top of Y</em><br>z = np.vstack((x,Y))<br><br><em class="markup--em markup--pre-em"># We stack x on the right of Y. We need to reshape x in order to stack it on the right of Y. </em><br>w = np.hstack((Y,x.reshape(2,1)))</code></pre><h3 name="7b87" id="7b87" class="graf graf--h3 graf-after--pre">Slicing ndarrays</h3><p name="ee93" id="ee93" class="graf graf--p graf-after--h3">NumPy provides a way to access subsets of ndarrays. This is known as <em class="markup--em markup--p-em">slicing</em>. Slicing is performed by combining indices with the colon <code class="markup--code markup--p-code">:</code> symbol inside the square brackets.</p><p name="ec9b" id="ec9b" class="graf graf--p graf-after--p">The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</p><ul class="postList"><li name="53d3" id="53d3" class="graf graf--li graf-after--p">The basic slice syntax is <code class="markup--code markup--li-code">i:j:k</code> where <em class="markup--em markup--li-em">i</em> is the starting index, <em class="markup--em markup--li-em">j</em> is the stopping index, and <em class="markup--em markup--li-em">k</em> is the step. This selects the <em class="markup--em markup--li-em">m </em>elements (in the corresponding dimension) with index values <em class="markup--em markup--li-em">i</em>, <em class="markup--em markup--li-em">i + k</em>, …, <em class="markup--em markup--li-em">i + (m — 1) k</em> where and <em class="markup--em markup--li-em">q</em> and <em class="markup--em markup--li-em">r</em> are the quotient and remainder obtained by dividing <em class="markup--em markup--li-em">j — i</em> by <em class="markup--em markup--li-em">k</em>: <em class="markup--em markup--li-em">j — i = q k + r</em>, so that <em class="markup--em markup--li-em">i + (m — 1) k &lt; j</em>.</li></ul><pre name="d03e" id="d03e" class="graf graf--pre graf-after--li">x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) </pre><pre name="4305" id="4305" class="graf graf--pre graf-after--pre">x[1:7:2] <br>array([1, 3, 5])</pre><ul class="postList"><li name="8a63" id="8a63" class="graf graf--li graf-after--pre">Negative <em class="markup--em markup--li-em">i</em> and <em class="markup--em markup--li-em">j</em> are interpreted as <em class="markup--em markup--li-em">n + i</em> and <em class="markup--em markup--li-em">n + j</em> where <em class="markup--em markup--li-em">n</em> is the number of elements in the corresponding dimension. Negative <em class="markup--em markup--li-em">k</em>makes stepping go towards smaller indices.</li></ul><pre name="6d11" id="6d11" class="graf graf--pre graf-after--li">x[-2:10] <br>array([8, 9])</pre><pre name="f510" id="f510" class="graf graf--pre graf-after--pre">x[-3:3:-1] <br>array([7, 6, 5, 4])</pre><ul class="postList"><li name="9c92" id="9c92" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">Ellipsis</strong></code> expands to the number of <code class="markup--code markup--li-code">:</code> objects needed for the selection tuple to index all dimensions. In most cases, this means that length of the expanded selection tuple is <code class="markup--code markup--li-code">x.ndim</code>. There may only be a single ellipsis present.</li></ul><pre name="718f" id="718f" class="graf graf--pre graf-after--li">x[…,0] <br>array([[1, 2, 3], [4, 5, 6]])</pre><ul class="postList"><li name="ed55" id="ed55" class="graf graf--li graf-after--pre">Each <code class="markup--code markup--li-code"><a href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" data-href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" class="markup--anchor markup--li-anchor" title="numpy.newaxis" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">newaxis</strong></a></code> object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the <code class="markup--code markup--li-code"><a href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" data-href="https://numpy.org/doc/stable/reference/constants.html#numpy.newaxis" class="markup--anchor markup--li-anchor" title="numpy.newaxis" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong">newaxis</strong></a></code> object in the selection tuple.</li></ul><pre name="39ce" id="39ce" class="graf graf--pre graf-after--li">x[:,np.newaxis,:,:].shape <br>(2, 1, 3, 1)</pre><blockquote name="c640" id="c640" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note:</strong></blockquote><blockquote name="eb10" id="eb10" class="graf graf--blockquote graf-after--blockquote">NumPy slicing creates a <a href="https://numpy.org/doc/stable/glossary.html#term-view" data-href="https://numpy.org/doc/stable/glossary.html#term-view" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">view</a> instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit <code class="markup--code markup--blockquote-code">copy()</code> is recommended.</blockquote><h3 name="9423" id="9423" class="graf graf--h3 graf-after--blockquote">Boolean Indexing, Set Operations, and Sorting</h3><p name="231f" id="231f" class="graf graf--p graf-after--h3">There are many situations in which we don’t know the indices of the elements we want to select.</p><p name="2510" id="2510" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Boolean indexing</strong></p><pre name="b4d4" id="b4d4" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a 5 x 5 ndarray that contains integers from 0 to 24</em><br>X = np.arange(25).reshape(5, 5)</code></pre><pre name="bdf5" id="bdf5" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We use Boolean indexing to assign the elements that are between 10 and 17 the value of -1</em><br>X[(X &gt; 10) &amp; (X &lt; 17)] = -1</code></pre><blockquote name="4dd3" id="4dd3" class="graf graf--blockquote graf-after--pre"><strong class="markup--strong markup--blockquote-strong">Note</strong>: Use Jupyter notebook to run below codes, always <strong class="markup--strong markup--blockquote-strong">import numpy as np</strong></blockquote><p name="2b40" id="2b40" class="graf graf--p graf-after--blockquote"><strong class="markup--strong markup--p-strong">Set operations</strong></p><pre name="a275" id="a275" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray</em><br>x = np.array([1,2,3,4,5])</code></pre><pre name="56eb" id="56eb" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create a rank 1 ndarray</em><br>y = np.array([6,7,2,8,4])</code></pre><pre name="6cbb" id="6cbb" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We use set operations to compare x and y:</em><br>print()<br>print(&#39;The elements that are both in x and y:&#39;, np.intersect1d(x,y))<br>print(&#39;The elements that are in x that are not in y:&#39;, np.setdiff1d(x,y))<br>print(&#39;All the elements of x and y:&#39;,np.union1d(x,y))</code></pre><blockquote name="bfd2" id="bfd2" class="graf graf--blockquote graf-after--pre"><em class="markup--em markup--blockquote-em">The elements that are both in x and y: [2 4]<br>The elements that are in x that are not in y: [1 3 5]<br>All the elements of x and y: [1 2 3 4 5 6 7 8]</em></blockquote><h3 name="bdde" id="bdde" class="graf graf--h3 graf-after--blockquote">Arithmetic operations and Broadcasting</h3><p name="cd2f" id="cd2f" class="graf graf--p graf-after--h3">NumPy allows element-wise operations on ndarrays as well as matrix operations.</p><p name="80c0" id="80c0" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Element-wise arithmetic operations on 1-D arrays</strong></p><pre name="a29e" id="a29e" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We create two rank 1 ndarrays</em><br>x = np.<strong class="markup--strong markup--pre-strong">array</strong>([1,2,3,4])<br>y = np.<strong class="markup--strong markup--pre-strong">array</strong>([5.5,6.5,7.5,8.5])</code></pre><pre name="f14a" id="f14a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code u-paddingRight0 u-marginRight0"><em class="markup--em markup--pre-em"># We perfrom basic element-wise operations using arithmetic symbols and functions</em><br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;x + y = &#39;, x + y)<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;add(x,y) = &#39;, np.add(x,y))<br><strong class="markup--strong markup--pre-strong">print</strong>()<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;x - y = &#39;, x - y)<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;subtract(x,y) = &#39;, np.subtract(x,y))<br><strong class="markup--strong markup--pre-strong">print</strong>()<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;x * y = &#39;, x * y)<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;multiply(x,y) = &#39;, np.multiply(x,y))<br><strong class="markup--strong markup--pre-strong">print</strong>()<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;x / y = &#39;, x / y)<br><strong class="markup--strong markup--pre-strong">print</strong>(&#39;divide(x,y) = &#39;, np.divide(x,y))</code></pre><p name="f994" id="f994" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Statistical functions</strong></p><pre name="d436" id="d436" class="graf graf--pre graf-after--p"><code class="markup--code markup--pre-code"># We create a 2 x 2 ndarray<br>X = np.array([[1,2], [3,4]])</code></pre><pre name="d01a" id="d01a" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code"># We print x<br>print()<br>print(&#39;X = \n&#39;, X)<br>print()</code></pre><pre name="928f" id="928f" class="graf graf--pre graf-after--pre"><code class="markup--code markup--pre-code">print(&#39;Average of all elements in X:&#39;, X.mean())<br>print(&#39;Average of all elements in the columns of X:&#39;, X.mean(axis=0))<br>print(&#39;Average of all elements in the rows of X:&#39;, X.mean(axis=1))<br>print()<br>print(&#39;Sum of all elements in X:&#39;, X.sum())<br>print(&#39;Sum of all elements in the columns of X:&#39;, X.sum(axis=0))<br>print(&#39;Sum of all elements in the rows of X:&#39;, X.sum(axis=1))<br>print()<br>print(&#39;Standard Deviation of all elements in X:&#39;, X.std())<br>print(&#39;Standard Deviation of all elements in the columns of X:&#39;, X.std(axis=0))<br>print(&#39;Standard Deviation of all elements in the rows of X:&#39;, X.std(axis=1))<br>print()<br>print(&#39;Median of all elements in X:&#39;, np.median(X))<br>print(&#39;Median of all elements in the columns of X:&#39;, np.median(X,axis=0))<br>print(&#39;Median of all elements in the rows of X:&#39;, np.median(X,axis=1))<br>print()<br>print(&#39;Maximum value of all elements in X:&#39;, X.max())<br>print(&#39;Maximum value of all elements in the columns of X:&#39;, X.max(axis=0))<br>print(&#39;Maximum value of all elements in the rows of X:&#39;, X.max(axis=1))<br>print()<br>print(&#39;Minimum value of all elements in X:&#39;, X.min())<br>print(&#39;Minimum value of all elements in the columns of X:&#39;, X.min(axis=0))<br>print(&#39;Minimum value of all elements in the rows of X:&#39;, X.min(axis=1))</code></pre><p name="8079" id="8079" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Broadcasting</strong></p><p name="3f59" id="3f59" class="graf graf--p graf-after--p">The term <strong class="markup--strong markup--p-strong">broadcasting</strong> describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is “broadcast” across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</p><p name="e0fb" id="e0fb" class="graf graf--p graf-after--p">numpy’s broadcasting rule relaxes this constraint when the arrays’ shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation:</p><pre name="cddb" id="cddb" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">numpy</strong> <strong class="markup--strong markup--pre-strong">import</strong> array<br>a = array([1.0,2.0,3.0])<br>b = 2.0<br>a * b<br>array([ 2.,  4.,  6.])</pre><figure name="c6b7" id="c6b7" class="graf graf--figure graf-after--pre"><img class="graf-image" data-image-id="1*wh1nGWxDLwRetDuBwjAmjQ.gif" data-width="421" data-height="121" src="https://cdn-images-1.medium.com/max/800/1*wh1nGWxDLwRetDuBwjAmjQ.gif"><figcaption class="imageCaption"><em class="markup--em markup--figure-em">In the simplest example of broadcasting, the scalar b is stretched to become an array of with the same shape as a so the shapes are compatible for element-by-element multiplication.</em></figcaption></figure><blockquote name="8633" id="8633" class="graf graf--blockquote graf-after--figure"><strong class="markup--strong markup--blockquote-strong">The Broadcasting Rule</strong></blockquote><blockquote name="70aa" id="70aa" class="graf graf--blockquote graf-after--blockquote"><strong class="markup--strong markup--blockquote-strong">In order to broadcast, the size of the trailing axes for both arrays in an operation must either be the same size or one of them must be one.</strong></blockquote><p name="8a79" id="8a79" class="graf graf--p graf-after--blockquote">Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. Below example adds a one-dimensional array to a two-dimensional array:</p><pre name="bdbe" id="bdbe" class="graf graf--pre graf-after--p"><strong class="markup--strong markup--pre-strong">from</strong> <strong class="markup--strong markup--pre-strong">numpy</strong> <strong class="markup--strong markup--pre-strong">import</strong> array<br>a = array([[ 0.0,  0.0,  0.0],<br>           [10.0, 10.0, 10.0],<br>           [20.0, 20.0, 20.0],<br>           [30.0, 30.0, 30.0]])<br>b = array([1.0, 2.0, 3.0])<br>a + b<br>array([[  1.,   2.,   3.],<br>       [ 11.,  12.,  13.],<br>       [ 21.,  22.,  23.],<br>       [ 31.,  32.,  33.]])</pre><h4 name="b134" id="b134" class="graf graf--h4 graf-after--pre">Previous article: <a href="https://nishantnitb.medium.com/python-packages-for-data-science-part-v-b3e519dc78df?source=your_stories_page-------------------------------------" data-href="https://nishantnitb.medium.com/python-packages-for-data-science-part-v-b3e519dc78df?source=your_stories_page-------------------------------------" class="markup--anchor markup--h4-anchor" rel="noopener" target="_blank">Python packages for Data Science (Part V)</a></h4><p name="2535" id="2535" class="graf graf--p graf-after--h4">Reference:</p><ol class="postList"><li name="64af" id="64af" class="graf graf--li graf-after--p"><a href="https://classroom.udacity.com/" data-href="https://classroom.udacity.com/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://classroom.udacity.com/</a></li><li name="17bf" id="17bf" class="graf graf--li graf-after--li graf--trailing"><a href="https://numpy.org/devdocs/user/absolute_beginners.html#how-to-create-a-basic-array" data-href="https://numpy.org/devdocs/user/absolute_beginners.html#how-to-create-a-basic-array" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://numpy.org/</a></li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@nishantnitb" class="p-author h-card">Nishant Sharma</a> on <a href="https://medium.com/p/218315a2a221"><time class="dt-published" datetime="2020-11-07T06:17:34.765Z">November 7, 2020</time></a>.</p><p><a href="https://medium.com/@nishantnitb/introduction-to-numpy-part-vi-218315a2a221" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 11, 2021.</p></footer></article></body></html>