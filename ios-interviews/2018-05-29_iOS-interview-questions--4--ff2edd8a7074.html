<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iOS interview questions (4)</title>
    <style>
      * {
        font-family: Georgia, Cambria, 'Times New Roman', Times, serif;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field='subtitle'],
      section[data-field='description'] {
        display: none;
      }
    </style>
  </head>
  <body>
    <article class="h-entry">
      <header>
        <h1 class="p-name">iOS interview questions (4)</h1>
      </header>
      <section data-field="subtitle" class="p-summary">
        Closures &amp; Strong Reference Cycles for Closures
      </section>
      <section data-field="description" class="p-summary">
        It is very hot topic for interview as it provides questions from
        beginner level to expert level, and most of the engineer got confused in
        it during discussion, even when you try to use it in your…
      </section>
      <section data-field="body" class="e-content">
        <section
          name="102e"
          class="section section--body section--first section--last"
        >
          <div class="section-divider"><hr class="section-divider" /></div>
          <div class="section-content">
            <div class="section-inner sectionLayout--insetColumn">
              <!-- <h3
                name="3349"
                id="3349"
                class="graf graf--h3 graf--leading graf--title"
              >
                <a
                  href="https://medium.com/ios-expert-series-or-interview-series/cracking-ios-interview-or-become-ios-expert-3-4130d699f52e"
                  data-href="https://medium.com/ios-expert-series-or-interview-series/cracking-ios-interview-or-become-ios-expert-3-4130d699f52e"
                  class="markup--anchor markup--h3-anchor"
                  target="_blank"
                  >iOS 2018 Series: Cracking iOS interview or Become iOS
                  expert (4)</a
                >
              </h3> -->
              <p name="9c15" id="9c15" class="graf graf--p graf-after--h3">
                <strong class="markup--strong markup--p-strong"
                  >Chapter 4: Closures &amp; Strong Reference Cycles for
                  Closures</strong
                >
              </p>
              <p name="7faf" id="7faf" class="graf graf--p graf-after--p">
                It is very hot topic for interview as it provides questions from
                beginner level to expert level, and most of the engineer got
                confused in it during discussion, even when you try to use it in
                your real life project, you may face some situation where you
                got confuse what to use and what not to!
              </p>
              <p name="29e6" id="29e6" class="graf graf--p graf-after--p">
                Closures in Swift are similar to blocks in C and Objective-C.
                Closures are self-contained blocks of functionality that can be
                passed around and used in your code.
              </p>
              <p name="fb10" id="fb10" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Closure Expression Syntax</strong
                >
              </p>
              <figure
                name="d1e5"
                id="d1e5"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*PXFpZu7hB_F3hzyuT8Pm-A.png"
                  data-width="285"
                  data-height="88"
                  src="https://cdn-images-1.medium.com/max/800/1*PXFpZu7hB_F3hzyuT8Pm-A.png"
                />
              </figure>
              <h3
                name="1dfe"
                id="1dfe"
                class="graf graf--h3 graf-after--figure"
              >
                Escaping Closures
              </h3>
              <p name="d3f3" id="d3f3" class="graf graf--p graf-after--h3">
                A closure is said to
                <em class="markup--em markup--p-em">escape</em> a function when
                the closure is passed as an argument to the function, but is
                called after the function returns. When you declare a function
                that takes a closure as one of its parameters, you can write
                <code class="markup--code markup--p-code">@escaping</code>
                before the parameter’s type to indicate that the closure is
                allowed to escape.
              </p>
              <figure
                name="6b3f"
                id="6b3f"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*vK5_03dA_bsTe1L5Rl2FjQ.png"
                  data-width="532"
                  data-height="68"
                  src="https://cdn-images-1.medium.com/max/800/1*vK5_03dA_bsTe1L5Rl2FjQ.png"
                />
              </figure>
              <p name="373a" id="373a" class="graf graf--p graf-after--figure">
                reversedNames = names.sorted(by: { s1, s2 in s1 &gt; s2 } )
                //<strong class="markup--strong markup--p-strong"
                  >(Line 1</strong
                >)
              </p>
              <p name="a535" id="a535" class="graf graf--p graf-after--p">
                reversedNames = names.sorted(by: { $0 &gt; $1 } ) //<strong
                  class="markup--strong markup--p-strong"
                  >(Line 2)</strong
                >
              </p>
              <p name="47db" id="47db" class="graf graf--p graf-after--p">
                Both lines are doing same thing,
                <strong class="markup--strong markup--p-strong">Line 1 </strong
                >is called
                <strong class="markup--strong markup--p-strong"
                  >Implicit Returns from Single-Expression Closures </strong
                >&amp;
                <strong class="markup--strong markup--p-strong">Line 2</strong>
                is called
                <strong class="markup--strong markup--p-strong"
                  >Shorthand Argument Names </strong
                >which can be used to refer to the values of the closure’s
                arguments by the names
                <code class="markup--code markup--p-code">$0</code>,
                <code class="markup--code markup--p-code">$1</code>,
                <code class="markup--code markup--p-code">$2</code>, and so on.
              </p>
              <h3 name="3d7f" id="3d7f" class="graf graf--h3 graf-after--p">
                <strong class="markup--strong markup--h3-strong"
                  >Strong Reference Cycles for Closures</strong
                >
              </h3>
              <p name="62f2" id="62f2" class="graf graf--p graf-after--h3">
                This strong reference cycle occurs because closures, like
                classes, are
                <em class="markup--em markup--p-em">reference types</em>.
              </p>
              <p name="2929" id="2929" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong">Case :</strong>
                if you assign a closure to a property of a class instance, and
                the body of that closure captures the instance.
              </p>
              <p name="590f" id="590f" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Description:</strong
                >
                This capture might occur because the closure’s body accesses a
                property of the instance, such as
                <code class="markup--code markup--p-code"
                  >self.someProperty</code
                >, or because the closure calls a method on the instance, such
                as
                <code class="markup--code markup--p-code"
                  >self.someMethod()</code
                >. In either case, these accesses cause the closure to “capture”
                <code class="markup--code markup--p-code">self</code>, creating
                a strong reference cycle.
              </p>
              <p name="8391" id="8391" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Solution:</strong
                >
                Weak or Unowned References, The appropriate choice of weak or
                unowned depends on the relationships between the different parts
                of your code.
              </p>
              <h3 name="e454" id="e454" class="graf graf--h3 graf-after--p">
                The Question: Unowned or Weak?
              </h3>
              <p name="7b43" id="7b43" class="graf graf--p graf-after--h3">
                Which one of the two reference types should you use?
              </p>
              <p
                name="5b19"
                id="5b19"
                class="graf graf--p graf--startsWithDoubleQuote graf-after--p"
              >
                <em class="markup--em markup--p-em"
                  >“Use a weak reference whenever it is valid for that reference
                  to become nil at some point during its lifetime. Conversely,
                  use an unowned reference when you know that the reference will
                  never be nil once it has been set during initialization.”</em
                >
              </p>
              <p
                name="0fe0"
                id="0fe0"
                class="graf graf--p graf--startsWithDoubleQuote graf-after--p"
              >
                <em class="markup--em markup--p-em"
                  >“Define a capture in a closure as an unowned reference when
                  the closure and the instance it captures will always refer to
                  each other, and will always be deallocated at the same
                  time.”</em
                >
              </p>
              <figure
                name="1ff0"
                id="1ff0"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*FcQ_mFFYecweE6U1e6hwtQ.png"
                  data-width="766"
                  data-height="431"
                  src="https://cdn-images-1.medium.com/max/800/1*FcQ_mFFYecweE6U1e6hwtQ.png"
                />
              </figure>
              <p name="e16a" id="e16a" class="graf graf--p graf-after--figure">
                There are two possible scenarios:
              </p>
              <ul class="postList">
                <li name="4a77" id="4a77" class="graf graf--li graf-after--p">
                  The closure has the same lifetime of the captured object, so
                  the closure will be reachable only until the object will be
                  reachable. The external object and the closure have the same
                  lifetime (e.g. simple back-references between and object and
                  its parent). In this case, you should declare the reference as
                  <strong class="markup--strong markup--li-strong"
                    >unowned</strong
                  >.<br />A common
                  <strong class="markup--strong markup--li-strong"
                    >example </strong
                  >is the
                  <code class="markup--code markup--li-code"
                    >[unowned self]</code
                  >
                  used in many examples of small closures that do something in
                  the context of their parent and that not being referenced
                  <em class="markup--em markup--li-em">or passed</em> anywhere
                  else do not outlive their parents.
                </li>
                <li name="a862" id="a862" class="graf graf--li graf-after--li">
                  The closure lifetime is independent from the one of the object
                  being captured, the closure could still be referenced when the
                  object is not reachable anymore. In this case you should
                  declare the reference as
                  <strong class="markup--strong markup--li-strong">weak</strong>
                  and verify it’s not nil before using it (don’t force
                  unwrap).<br />A common
                  <strong class="markup--strong markup--li-strong"
                    >example </strong
                  >of this is the
                  <code class="markup--code markup--li-code"
                    >[weak delegate = self.delegate!]</code
                  >
                  you can see in some examples of closure referencing a
                  completely unrelated (lifetime-wise) delegate object.
                </li>
              </ul>
              <h3 name="eebd" id="eebd" class="graf graf--h3 graf-after--li">
                lazy var
              </h3>
              <p name="99ec" id="99ec" class="graf graf--p graf-after--h3">
                <em class="markup--em markup--p-em"
                  >A lazy stored property is a property whose initial value is
                  not calculated until the first time it is used. You indicate a
                  lazy stored property by writing the </em
                ><code class="markup--code markup--p-code"
                  ><em class="markup--em markup--p-em">lazy</em></code
                ><em class="markup--em markup--p-em">
                  modifier before its declaration.</em
                >
              </p>
              <h3 name="2b8e" id="2b8e" class="graf graf--h3 graf-after--p">
                defer keyword
              </h3>
              <p name="96ee" id="96ee" class="graf graf--p graf-after--h3">
                What defer does is not obvious at first. Defer will wait to
                execute a block of code until the current scope (loop, method,
                etc) is exiting. And it will execute that code whether the scope
                is exiting cleanly, from a guard, or while an error is being
                thrown.
              </p>
              <p name="5bd3" id="5bd3" class="graf graf--p graf-after--p">
                Here’s the most basic of examples. The defer block exists before
                the main body of the code, but it’s not called until afterwards.
              </p>
              <figure
                name="0ca8"
                id="0ca8"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*b2jExLdfYOdwUoQoHGy1lQ.png"
                  data-width="1000"
                  data-height="180"
                  src="https://cdn-images-1.medium.com/max/800/1*b2jExLdfYOdwUoQoHGy1lQ.png"
                />
              </figure>
              <p name="9825" id="9825" class="graf graf--p graf-after--figure">
                This can be useful if, for example, there are resources you need
                to ensure are cleaned up before leaving the current scope.
              </p>
              <h3 name="c610" id="c610" class="graf graf--h3 graf-after--p">
                Conclusion
              </h3>
              <p name="2f8d" id="2f8d" class="graf graf--p graf-after--h3">
                Does using defensively only weak references make sense? No, from
                both the point of view of performance and code clarity.
              </p>
              <p name="0176" id="0176" class="graf graf--p graf-after--p">
                Using the right type of capture modifier makes explicit some
                lifetime characteristics of our code and makes it harder to
                reach wrong conclusions about how the code behaves when someone
                else, or future you, will read what you wrote.
              </p>
              <p name="867f" id="867f" class="graf graf--p graf-after--p">
                Hope you are loving it!
              </p>
              <!-- <p
                name="a8f4"
                id="a8f4"
                class="graf graf--p graf-after--p graf--trailing"
              >
                Goto next Chapter:
                <a
                  href="https://medium.com/@nishantsamsung09/ios-2018-series-cracking-ios-interview-or-become-ios-expert-5-c360f0abde27"
                  data-href="https://medium.com/@nishantsamsung09/ios-2018-series-cracking-ios-interview-or-become-ios-expert-5-c360f0abde27"
                  class="markup--anchor markup--p-anchor"
                  target="_blank"
                  >classes, structs &amp; enum in swift.</a
                >
              </p> -->
            </div>
          </div>
        </section>
      </section>
      <!-- <footer>
        <p>
          By
          <a href="https://medium.com/@nishantnitb" class="p-author h-card"
            >Nishant Sharma</a
          >
          on
          <a href="https://medium.com/p/ff2edd8a7074"
            ><time class="dt-published" datetime="2018-05-29T14:21:49.644Z"
              >May 29, 2018</time
            ></a
          >.
        </p>
        <p>
          <a
            href="https://medium.com/@nishantnitb/ios-2018-series-cracking-ios-interview-or-become-ios-expert-4-ff2edd8a7074"
            class="p-canonical"
            >Canonical link</a
          >
        </p>
        <p>
          Exported from <a href="https://medium.com">Medium</a> on February 11,
          2021.
        </p>
      </footer> -->
    </article>
  </body>
</html>
