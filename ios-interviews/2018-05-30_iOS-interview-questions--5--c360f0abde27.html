<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>iOS interview questions (5)</title>
    <style>
      * {
        font-family: Georgia, Cambria, 'Times New Roman', Times, serif;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field='subtitle'],
      section[data-field='description'] {
        display: none;
      }
    </style>
  </head>
  <body>
    <article class="h-entry">
      <header>
        <h1 class="p-name">iOS interview questions (5)</h1>
      </header>
      <section data-field="subtitle" class="p-summary">
        Enums, Struct and Class in swift
      </section>
      <section data-field="description" class="p-summary">
        Safety implies that it&#39;s difficult to accidentally write code that
        runs amok, corrupting memory and producing hard-to-find bugs. Swift
        makes your work safer because it tries to make it obvious when…
      </section>
      <section data-field="body" class="e-content">
        <section
          name="848c"
          class="section section--body section--first section--last"
        >
          <div class="section-divider"><hr class="section-divider" /></div>
          <div class="section-content">
            <div class="section-inner sectionLayout--insetColumn">
              <h3
                name="2fac"
                id="2fac"
                class="graf graf--h3 graf--leading graf--title"
              >
                iOS 2018 Series: Cracking iOS interview or Become iOS expert (5)
              </h3>
              <p name="a78f" id="a78f" class="graf graf--p graf-after--h3">
                <strong class="markup--strong markup--p-strong"
                  >Chapter 5: Enums, Struct and Class</strong
                >
              </p>
              <p name="7d00" id="7d00" class="graf graf--p graf-after--p">
                As we all know, Three big selling points of Swift are its
                <strong class="markup--strong markup--p-strong">safety</strong>,
                <strong class="markup--strong markup--p-strong">speed</strong>
                and
                <strong class="markup--strong markup--p-strong"
                  >simplicity</strong
                >.
              </p>
              <p name="09a1" id="09a1" class="graf graf--p graf-after--p">
                Safety implies that it’s difficult to accidentally write code
                that runs amok, corrupting memory and producing hard-to-find
                bugs. Swift makes your work safer because it tries to make it
                obvious when you have a bug by showing you problems at compile
                time, rather than hanging you out to dry at runtime.
              </p>
              <p name="1221" id="1221" class="graf graf--p graf-after--p">
                Moreover, because Swift lets you clearly express your intent,
                the optimizer can go to town to help your code run lightning
                fast.
              </p>
              <p name="c77d" id="c77d" class="graf graf--p graf-after--p">
                The Swift language core is simple and highly-regularized, thanks
                to being built upon a surprisingly small number of concepts.
                Despite its relatively simple rules, you can do amazing things.
              </p>
              <p name="c316" id="c316" class="graf graf--p graf-after--p">
                The key to making this happen is the Swift
                <strong class="markup--strong markup--p-strong"
                  >type system</strong
                >:
              </p>
              <figure
                name="1845"
                id="1845"
                class="graf graf--figure graf-after--p"
              >
                <img
                  class="graf-image"
                  data-image-id="1*EFWmqnuE8gtuEy-lZWQZxQ.png"
                  data-width="700"
                  data-height="195"
                  src="https://cdn-images-1.medium.com/max/800/1*EFWmqnuE8gtuEy-lZWQZxQ.png"
                />
              </figure>
              <h3
                name="e5e4"
                id="e5e4"
                class="graf graf--h3 graf-after--figure"
              >
                Structures and Enumerations Are Value Types
              </h3>
              <p name="c0f2" id="c0f2" class="graf graf--p graf-after--h3">
                You’ve actually been using value types extensively throughout
                the previous chapters. In fact, all of the basic types in
                Swift — integers, floating-point numbers, Booleans, strings,
                arrays and dictionaries — are value types, and are implemented
                as structures behind the scenes.
              </p>
              <h3 name="6c51" id="6c51" class="graf graf--h3 graf-after--p">
                Enums
              </h3>
              <p name="8442" id="8442" class="graf graf--p graf-after--h3">
                Enums in Swift have a few more features like you can add an
                initializer method or custom methods to extend the
                functionality. If you didn’t want to select a specific member
                value when creating an instance then you can provide an
                <code class="markup--code markup--p-code">init</code> method
                which defaults to one of the member values.
              </p>
              <pre
                name="5580"
                id="5580"
                class="graf graf--pre graf-after--p"
              ><code class="markup--code markup--pre-code">enum Type {<br>    case Friend<br>    case Family<br>    case Coworker<br>    case Other</code></pre>
              <pre
                name="5cf6"
                id="5cf6"
                class="graf graf--pre graf-after--pre"
              ><code class="markup--code markup--pre-code">    init() {<br>        self = .Friend<br>    }<br>}</code></pre>
              <p name="a0ce" id="a0ce" class="graf graf--p graf-after--pre">
                <strong class="markup--strong markup--p-strong"
                  >Explain the difference between raw and associated values in
                  Swift.</strong
                >
              </p>
              <p name="b11e" id="b11e" class="graf graf--p graf-after--p">
                This question tests the developer’s understanding of enumeration
                in Swift. Enumeration provides a type-safe method of working
                with a group of related values. Raw values are compile time-set
                values directly assigned to every case within an enumeration, as
                in the example detailed below:
              </p>
              <pre
                name="fdda"
                id="fdda"
                class="graf graf--pre graf-after--p"
              >enum Alphabet: Int {<br>case A = 1<br>case B<br>case C<br>}</pre>
              <p name="7e14" id="7e14" class="graf graf--p graf-after--pre">
                In the above example code, case “A” was explicitly assigned a
                raw value integer of 1, while cases “B” and “C” were implicitly
                assigned raw value integers of 2 and 3, respectively. Associated
                values allow you to store values of other types alongside case
                values, as demonstrated below:
              </p>
              <pre
                name="30ba"
                id="30ba"
                class="graf graf--pre graf-after--p"
              >enum Alphabet: Int {<br>case A(Int)<br>case B<br>case C(String)<br>}</pre>
              <h3 name="e8f9" id="e8f9" class="graf graf--h3 graf-after--pre">
                Structures
              </h3>
              <p name="4f04" id="4f04" class="graf graf--p graf-after--h3">
                <code class="markup--code markup--p-code"
                  >struct Resolution {<br />
                  var width = 0<br />
                  var height = 0<br />}</code
                >
              </p>
              <p name="6343" id="6343" class="graf graf--p graf-after--p">
                All structures have an automatically-generated
                <em class="markup--em markup--p-em">memberwise initializer</em>,
                which you can use to initialize the member properties of new
                structure instances. Unlike structures, class instances do not
                receive a default memberwise initializer.
              </p>
              <p name="0500" id="0500" class="graf graf--p graf-after--p">
                <code class="markup--code markup--p-code"
                  >let vga = Resolution(width: 640, height: 480)</code
                >
              </p>
              <h3 name="cc67" id="cc67" class="graf graf--h3 graf-after--p">
                Identity Operators
              </h3>
              <p name="b1db" id="b1db" class="graf graf--p graf-after--h3">
                It can sometimes be useful to find out if two constants or
                variables refer to exactly the same instance of a class. To
                enable this, Swift provides two identity operators:
              </p>
              <ul class="postList">
                <li name="3768" id="3768" class="graf graf--li graf-after--p">
                  Identical to (<code class="markup--code markup--li-code"
                    >===</code
                  >)
                </li>
                <li name="217d" id="217d" class="graf graf--li graf-after--li">
                  Not identical to (<code class="markup--code markup--li-code"
                    >!==</code
                  >)
                </li>
              </ul>
              <h3 name="ee5b" id="ee5b" class="graf graf--h3 graf-after--li">
                Classes
              </h3>
              <p name="8df6" id="8df6" class="graf graf--p graf-after--h3">
                Classes and structures have a similar definition syntax. You
                introduce classes with the
                <code class="markup--code markup--p-code">class</code> keyword
                and structures with the
                <code class="markup--code markup--p-code">struct</code> keyword.
                Both place their entire definition within a pair of braces
              </p>
              <p name="e8a4" id="e8a4" class="graf graf--p graf-after--p">
                <code class="markup--code markup--p-code"
                  >class VideoMode {<br />var resolution = Resolution()<br />var
                  interlaced = false<br />var frameRate = 0.0<br />var name:
                  String?<br />}</code
                >
              </p>
              <h3 name="dba2" id="dba2" class="graf graf--h3 graf-after--p">
                Choosing Between Classes and Structures
              </h3>
              <p name="4b8d" id="4b8d" class="graf graf--p graf-after--h3">
                <strong class="markup--strong markup--p-strong"
                  >Classes have additional capabilities that structures do
                  not:</strong
                >
              </p>
              <ul class="postList">
                <li name="98ba" id="98ba" class="graf graf--li graf-after--p">
                  Inheritance enables one class to inherit the characteristics
                  of another.
                </li>
                <li name="c817" id="c817" class="graf graf--li graf-after--li">
                  Type casting enables you to check and interpret the type of a
                  class instance at runtime.
                </li>
                <li name="62da" id="62da" class="graf graf--li graf-after--li">
                  Deinitializers enable an instance of a class to free up any
                  resources it has assigned.
                </li>
                <li name="e22c" id="e22c" class="graf graf--li graf-after--li">
                  Reference counting allows more than one reference to a class
                  instance.
                </li>
              </ul>
              <p name="511c" id="511c" class="graf graf--p graf-after--li">
                <strong class="markup--strong markup--p-strong"
                  >Consider creating a structure when one or more of these
                  conditions apply:</strong
                >
              </p>
              <ul class="postList">
                <li name="03ef" id="03ef" class="graf graf--li graf-after--p">
                  The structure’s primary purpose is to encapsulate a few
                  relatively simple data values.
                </li>
                <li name="968a" id="968a" class="graf graf--li graf-after--li">
                  It is reasonable to expect that the encapsulated values will
                  be copied rather than referenced when you assign or pass
                  around an instance of that structure.
                </li>
                <li name="1d3f" id="1d3f" class="graf graf--li graf-after--li">
                  Any properties stored by the structure are themselves value
                  types, which would also be expected to be copied rather than
                  referenced.
                </li>
                <li name="0d32" id="0d32" class="graf graf--li graf-after--li">
                  The structure does not need to inherit properties or behavior
                  from another existing type.
                </li>
              </ul>
              <h3 name="9fff" id="9fff" class="graf graf--h3 graf-after--li">
                Bonus : SubClass vs Categories vs Extensions
              </h3>
              <p name="64f1" id="64f1" class="graf graf--p graf-after--h3">
                Subclassing in simple words is
                <strong class="markup--strong markup--p-strong"
                  >changing the behavior of properties or methods of an existing
                  class.</strong
                >
              </p>
              <ol class="postList">
                <li name="b2d9" id="b2d9" class="graf graf--li graf-after--p">
                  <strong class="markup--strong markup--li-strong"
                    >Source code</strong
                  >
                </li>
              </ol>
              <p name="e522" id="e522" class="graf graf--p graf-after--li">
                Categories provide a way to add methods to a class even if its
                source code is not available to you. ex: NSString
              </p>
              <p name="6a36" id="6a36" class="graf graf--p graf-after--p">
                Extensions — This includes the ability to extend types for which
                you do not have access to the original source code (known as
                <em class="markup--em markup--p-em">retroactive modeling</em>).
              </p>
              <p name="fe0d" id="fe0d" class="graf graf--p graf-after--p">
                2.<strong class="markup--strong markup--p-strong">
                  Instance variable/Properties</strong
                >
              </p>
              <p name="69c9" id="69c9" class="graf graf--p graf-after--p">
                Category : Not possible, Note that
                <strong class="markup--strong markup--p-strong"
                  >in a category you can’t add an instance variable</strong
                >, since methods within a category are added to a class at
                runtime.
              </p>
              <p name="5ed0" id="5ed0" class="graf graf--p graf-after--p">
                Extensions : Possible, Extensions can add instance variables.
              </p>
              <p name="6f6d" id="6f6d" class="graf graf--p graf-after--p">
                3.
                <strong class="markup--strong markup--p-strong"
                  >Accessibility to Inherited classes.</strong
                >
              </p>
              <p name="f027" id="f027" class="graf graf--p graf-after--p">
                Category — All methods defined inside a category are also
                available to the inherited class
              </p>
              <p name="d8e3" id="d8e3" class="graf graf--p graf-after--p">
                Extensions — All properties and methods defined inside a class
                extension are not even available to inherited class.
              </p>
              <p name="4a71" id="4a71" class="graf graf--p graf-after--p">
                <strong class="markup--strong markup--p-strong"
                  >Conclusion</strong
                >:
              </p>
              <ul class="postList">
                <li name="4405" id="4405" class="graf graf--li graf-after--p">
                  <em class="markup--em markup--li-em"
                    >Subclassing is better option if you want to customize an
                    existing stuffs or functionalities, and Category is a best
                    option if you want to add additional functionalities to an
                    existing class</em
                  >
                </li>
                <li name="63de" id="63de" class="graf graf--li graf-after--li">
                  Usually people will use extensions to hide private information
                  of a class without exposing them to access from any other
                  class.
                </li>
              </ul>
              <p name="bac7" id="bac7" class="graf graf--p graf-after--li">
                Hope you are loving it!
              </p>
              <!-- <p
                name="0653"
                id="0653"
                class="graf graf--p graf-after--p graf--trailing"
              >
                Goto Chapter:
                <a
                  href="https://medium.com/ios-expert-series-or-interview-series/ios-2018-series-cracking-ios-interview-or-become-ios-expert-6-a3e5a77c2405"
                  data-href="https://medium.com/ios-expert-series-or-interview-series/ios-2018-series-cracking-ios-interview-or-become-ios-expert-6-a3e5a77c2405"
                  class="markup--anchor markup--p-anchor"
                  target="_blank"
                  ><strong class="markup--strong markup--p-strong"
                    >Concurrency</strong
                  >
                  -<strong class="markup--strong markup--p-strong">
                    DispatchGroup and OperationQueue.</strong
                  ></a
                >
              </p> -->
            </div>
          </div>
        </section>
      </section>
      <!-- <footer>
        <p>
          By
          <a href="https://medium.com/@nishantnitb" class="p-author h-card"
            >Nishant Sharma</a
          >
          on
          <a href="https://medium.com/p/c360f0abde27"
            ><time class="dt-published" datetime="2018-05-30T12:54:37.861Z"
              >May 30, 2018</time
            ></a
          >.
        </p>
        <p>
          <a
            href="https://medium.com/@nishantnitb/ios-2018-series-cracking-ios-interview-or-become-ios-expert-5-c360f0abde27"
            class="p-canonical"
            >Canonical link</a
          >
        </p>
        <p>
          Exported from <a href="https://medium.com">Medium</a> on February 11,
          2021.
        </p>
      </footer> -->
    </article>
  </body>
</html>
