<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Writing High-Performance Swift Code</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Writing High-Performance Swift Code</h1>
</header>
<section data-field="subtitle" class="p-summary">
When developing an iOS app, it’s critical that your app has good performance. Your users expect it, and it will hurt your reviews if your…
</section>
<section data-field="body" class="e-content">
<section name="f7f9" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8209" id="8209" class="graf graf--h3 graf--leading graf--title">Writing High-Performance Swift Code</h3><figure name="e12d" id="e12d" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Wzzy-sqTMjkuLG0WvLophA.png" data-width="408" data-height="155" src="https://cdn-images-1.medium.com/max/800/1*Wzzy-sqTMjkuLG0WvLophA.png"></figure><p name="9993" id="9993" class="graf graf--p graf-after--figure">When developing an iOS app, it’s critical that your app has good performance. Your users expect it, and it will hurt your reviews if your app appears unresponsive or slow.</p><p name="ab3f" id="ab3f" class="graf graf--p graf-after--p">Even during your interviews, <strong class="markup--strong markup--p-strong">Interviewer can ask you what you have done to write high performance swift code or how do you review the code for performance optimization?</strong></p><p name="915e" id="915e" class="graf graf--p graf-after--p">In a <strong class="markup--strong markup--p-strong">nutshell</strong>, Our answer should be:</p><ol class="postList"><li name="e7fc" id="e7fc" class="graf graf--li graf-after--p">Using an <code class="markup--code markup--li-code"><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSDictionary" data-href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSDictionaryClassClstr/Description.html#//apple_ref/occ/cl/NSDictionary" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">NSDictionary</a></code> object to hold a single key-value pair is significantly more expensive than simply allocating a variable to hold the data. Creating thousands of such dictionaries wastes memory.</li><li name="68f6" id="68f6" class="graf graf--li graf-after--li">In performance critical code, one often will want to restrict this dynamic behavior <strong class="markup--strong markup--li-strong">using final</strong> keyword i.e. Reducing Dynamic Dispatch.</li><li name="880b" id="880b" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">private</strong></code><strong class="markup--strong markup--li-strong"> or </strong><code class="markup--code markup--li-code u-paddingRight0 u-marginRight0"><strong class="markup--strong markup--li-strong">fileprivate</strong> </code>keywords to a declaration restricts the visibility of the declaration to the file, allows the compiler to be able to ascertain all other potentially overriding declarations.</li><li name="68d9" id="68d9" class="graf graf--li graf-after--li">Using Container Types Efficiently, <strong class="markup--strong markup--li-strong">Use value types in Array:</strong> By using value types without reference types, one can avoid additional retain, release traffic inside.</li><li name="da28" id="da28" class="graf graf--li graf-after--li">Use ContiguousArray with reference types when NSArray bridging is unnecessary.</li><li name="f7e6" id="f7e6" class="graf graf--li graf-after--li">Use inplace mutation instead of object-reassignment</li><li name="b8cf" id="b8cf" class="graf graf--li graf-after--li">Put generic declarations in the same module where they are used</li><li name="f882" id="f882" class="graf graf--li graf-after--li">Use copy-on-write semantics for large values</li><li name="9c2a" id="9c2a" class="graf graf--li graf-after--li">Mark protocols that are only satisfied by classes as class-protocols</li></ol><p name="eb4a" id="eb4a" class="graf graf--p graf-after--li">We have seen the answer in nutshell, its time to dive into details. All the details mentioned in this article has been referred from apple swift docs only.</p><h4 name="b092" id="b092" class="graf graf--h4 graf-after--p">1. Dynamic Dispatch</h4><p name="8999" id="8999" class="graf graf--p graf-after--h4">Swift by default is a very dynamic language like Objective-C. Unlike Objective-C, Swift gives the programmer the ability to improve runtime performance when necessary by removing or reducing this dynamism.</p><p name="ac34" id="ac34" class="graf graf--p graf-after--p">In Swift, dynamic dispatch defaults to indirect invocation through a vtable <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id8" data-href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id8" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[1]</a>. If one attaches the <code class="markup--code markup--p-code">dynamic</code> keyword to the declaration, Swift will emit calls via Objective-C message send instead. In both cases this is slower than a direct function call because it prevents many compiler optimizations <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id9" data-href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id9" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[2]</a> in addition to the overhead of performing the indirect call itself. In performance critical code, one often will want to restrict this dynamic behavior.</p><p name="6ded" id="6ded" class="graf graf--p graf-after--p">Thus in the following code snippet, <code class="markup--code markup--p-code">a.aProperty</code>, <code class="markup--code markup--p-code">a.doSomething()</code> and <code class="markup--code markup--p-code">a.doSomethingElse()</code> will all be invoked via dynamic dispatch:</p><pre name="3b23" id="3b23" class="graf graf--pre graf-after--p">class A {<br>  var aProperty: [Int]<br>  func doSomething() { ... }<br>  dynamic doSomethingElse() { ... }<br>}</pre><pre name="4039" id="4039" class="graf graf--pre graf-after--pre">class B : A {<br>  override var aProperty {<br>    get { ... }<br>    set { ... }<br>  }</pre><pre name="cd17" id="cd17" class="graf graf--pre graf-after--pre">  override func doSomething() { ... }<br>}</pre><pre name="778c" id="778c" class="graf graf--pre graf-after--pre">func usingAnA(_ a: A) {<br>  a.doSomething()<br>  a.aProperty = ...<br>}</pre><h4 name="1562" id="1562" class="graf graf--h4 graf-after--pre">2. Use ‘final’ when you know the declaration does not need to be overridden</h4><p name="288b" id="288b" class="graf graf--p graf-after--h4">The <code class="markup--code markup--p-code">final</code> keyword is a restriction on a declaration of a class, a method, or a property such that the declaration cannot be overridden. This implies that the compiler can emit direct function calls instead of indirect calls.</p><h4 name="7a94" id="7a94" class="graf graf--h4 graf-after--p">3. Use ‘private’ and ‘fileprivate’ when declaration does not need to be accessed outside of file</h4><p name="df04" id="df04" class="graf graf--p graf-after--h4">Applying the <code class="markup--code markup--p-code">private</code> or <code class="markup--code markup--p-code">fileprivate</code> keywords to a declaration restricts the visibility of the declaration to the file in which it is declared. This allows the compiler to be able to ascertain all other potentially overriding declarations. Thus the absence of any such declarations enables the compiler to infer the <code class="markup--code markup--p-code">final</code> keyword automatically and remove indirect calls for methods and field accesses accordingly.</p><h4 name="1ea6" id="1ea6" class="graf graf--h4 graf-after--p">4. Use value types in Array</h4><p name="beef" id="beef" class="graf graf--p graf-after--h4">In Swift, types can be divided into two different categories: value types (structs, enums, tuples) and reference types (classes). A key distinction is that value types cannot be included inside an NSArray. Thus when using value types, the optimizer can remove most of the overhead in Array that is necessary to handle the possibility of the array being backed an NSArray.</p><p name="146c" id="146c" class="graf graf--p graf-after--p">Additionally, In contrast to reference types, value types only need reference counting if they contain, recursively, a reference type. By using value types without reference types, one can avoid additional retain, release traffic inside Array.</p><pre name="ad5c" id="ad5c" class="graf graf--pre graf-after--p">// Don&#39;t use a class here.<br>struct PhonebookEntry {<br>  var name : String<br>  var number : [Int]<br>}</pre><pre name="31d3" id="31d3" class="graf graf--pre graf-after--pre">var a : [PhonebookEntry]</pre><p name="d6ae" id="d6ae" class="graf graf--p graf-after--pre">Keep in mind that there is a trade-off between using large value types and using reference types. In certain cases, the overhead of copying and moving around large value types will outweigh the cost of removing the bridging and retain/release overhead.</p><h4 name="f158" id="f158" class="graf graf--h4 graf-after--p">5. Use ContiguousArray with reference types when NSArray bridging is unnecessary</h4><p name="95f6" id="95f6" class="graf graf--p graf-after--h4">If you need an array of reference types and the array does not need to be bridged to NSArray, use ContiguousArray instead of Array:</p><pre name="3980" id="3980" class="graf graf--pre graf-after--p">class C { ... }<br>var a: ContiguousArray&lt;C&gt; = [C(...), C(...), ..., C(...)]<br><br></pre><h4 name="8022" id="8022" class="graf graf--h4 graf-after--pre">6. Use inplace mutation instead of object-reassignment</h4><p name="6c88" id="6c88" class="graf graf--p graf-after--h4">All standard library containers in Swift are value types that use COW (copy-on-write) <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id11" data-href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id11" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[4]</a> to perform copies instead of explicit copies. In many cases this allows the compiler to elide unnecessary copies by retaining the container instead of performing a deep copy. This is done by only copying the underlying container if the reference count of the container is greater than 1 and the container is mutated. For instance in the following, no copying will occur when <code class="markup--code markup--p-code">d</code> is assigned to <code class="markup--code markup--p-code">c</code>, but when <code class="markup--code markup--p-code">d</code> undergoes structural mutation by appending <code class="markup--code markup--p-code">2</code>, <code class="markup--code markup--p-code">d</code> will be copied and then <code class="markup--code markup--p-code">2</code> will be appended to <code class="markup--code markup--p-code">d</code>:</p><pre name="b2d3" id="b2d3" class="graf graf--pre graf-after--p">var c: [Int] = [ ... ]<br>var d = c        // No copy will occur here.<br>d.append(2)      // A copy *does* occur here.</pre><p name="4d05" id="4d05" class="graf graf--p graf-after--pre">Sometimes COW can introduce additional unexpected copies if the user is not careful. An example of this is attempting to perform mutation via object-reassignment in functions. In Swift, all parameters are passed in at +1, i.e. the parameters are retained before a callsite, and then are released at the end of the callee. This means that if one writes a function like the following:</p><pre name="c8f5" id="c8f5" class="graf graf--pre graf-after--p">func append_one(_ a: [Int]) -&gt; [Int] {<br>  a.append(1)<br>  return a<br>}</pre><pre name="a617" id="a617" class="graf graf--pre graf-after--pre">var a = [1, 2, 3]<br>a = append_one(a)</pre><p name="b4ad" id="b4ad" class="graf graf--p graf-after--pre"><code class="markup--code markup--p-code">a</code> may be copied <a href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id12" data-href="https://github.com/apple/swift/blob/master/docs/OptimizationTips.rst#id12" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[5]</a> despite the version of <code class="markup--code markup--p-code">a</code> without one appended to it has no uses after <code class="markup--code markup--p-code">append_one</code> due to the assignment. This can be avoided through the usage of <code class="markup--code markup--p-code">inout</code> parameters:</p><pre name="fc45" id="fc45" class="graf graf--pre graf-after--p">func append_one_in_place(a: inout [Int]) {<br>  a.append(1)<br>}</pre><pre name="139e" id="139e" class="graf graf--pre graf-after--pre">var a = [1, 2, 3]<br>append_one_in_place(&amp;a)</pre><h4 name="dbad" id="dbad" class="graf graf--h4 graf-after--pre">7. Put generic declarations in the same module where they are used</h4><p name="cc47" id="cc47" class="graf graf--p graf-after--h4">The optimizer can only perform specialization if the definition of the generic declaration is visible in the current Module. This can only occur if the declaration is in the same file as the invocation of the generic, unless the <code class="markup--code markup--p-code">-whole-module-optimization</code> flag is used. <em class="markup--em markup--p-em">NOTE</em> The standard library is a special case. Definitions in the standard library are visible in all modules and available for specialization.</p><h4 name="d6ee" id="d6ee" class="graf graf--h4 graf-after--p">8. Use copy-on-write semantics for large values</h4><p name="308d" id="308d" class="graf graf--p graf-after--h4">To eliminate the cost of copying large values adopt copy-on-write behavior. The easiest way to implement copy-on-write is to compose existing copy-on-write data structures, such as Array. Swift arrays are values, but the content of the array is not copied around every time the array is passed as an argument because it features copy-on-write traits.</p><p name="2abe" id="2abe" class="graf graf--p graf-after--p">In our Tree example we eliminate the cost of copying the content of the tree by wrapping it in an array. This simple change has a major impact on the performance of our tree data structure, and the cost of passing the array as an argument drops from being O(n), depending on the size of the tree to O(1).</p><pre name="2444" id="2444" class="graf graf--pre graf-after--p">struct Tree : P {<br>  var node : [P?]<br>  init() {<br>    node = [thing]<br>  }<br>}</pre><p name="53d2" id="53d2" class="graf graf--p graf-after--pre">There are two obvious disadvantages of using Array for COW semantics. The first problem is that Array exposes methods like “append” and “count” that don’t make any sense in the context of a value wrapper. These methods can make the use of the reference wrapper awkward. It is possible to work around this problem by creating a wrapper struct that will hide the unused APIs and the optimizer will remove this overhead, but this wrapper will not solve the second problem. The Second problem is that Array has code for ensuring program safety and interaction with Objective-C. Swift checks if indexed accesses fall within the array bounds and when storing a value if the array storage needs to be extended. These runtime checks can slow things down.</p><p name="802f" id="802f" class="graf graf--p graf-after--p">An alternative to using Array is to implement a dedicated copy-on-write data structure to replace Array as the value wrapper. The example below shows how to construct such a data structure:</p><pre name="243a" id="243a" class="graf graf--pre graf-after--p">final class Ref&lt;T&gt; {<br>  var val : T<br>  init(_ v : T) {val = v}<br>}</pre><pre name="65c4" id="65c4" class="graf graf--pre graf-after--pre">struct Box&lt;T&gt; {<br>    var ref : Ref&lt;T&gt;<br>    init(_ x : T) { ref = Ref(x) }</pre><pre name="f75b" id="f75b" class="graf graf--pre graf-after--pre">    var value: T {<br>        get { return ref.val }<br>        set {<br>          if (!isKnownUniquelyReferenced(&amp;ref)) {<br>            ref = Ref(newValue)<br>            return<br>          }<br>          ref.val = newValue<br>        }<br>    }<br>}</pre><p name="9d38" id="9d38" class="graf graf--p graf-after--pre">The type <code class="markup--code markup--p-code">Box</code> can replace the array in the code sample above.</p><h4 name="2240" id="2240" class="graf graf--h4 graf-after--p">9. Mark protocols that are only satisfied by classes as class-protocols</h4><p name="03c8" id="03c8" class="graf graf--p graf-after--h4">Swift can limit protocols adoption to classes only. One advantage of marking protocols as class-only is that the compiler can optimize the program based on the knowledge that only classes satisfy a protocol. For example, the ARC memory management system can easily retain (increase the reference count of an object) if it knows that it is dealing with a class. Without this knowledge the compiler has to assume that a struct may satisfy the protocol and it needs to be prepared to retain or release non-trivial structures, which can be expensive.</p><p name="39e9" id="39e9" class="graf graf--p graf-after--p">If it makes sense to limit the adoption of protocols to classes then mark protocols as class-only protocols to get better runtime performance.</p><pre name="c4bd" id="c4bd" class="graf graf--pre graf-after--p">protocol Pingable : AnyObject { func ping() -&gt; Int }</pre><p name="8f81" id="8f81" class="graf graf--p graf-after--pre">Hope this article is useful for people looking to gain knowledge on high performance swift code or to crack iOS lead interviews, Please ❤️ to recommend this post to others 😊. Let me know your feedback. :)</p><p name="5957" id="5957" class="graf graf--p graf-after--p">References:</p><ol class="postList"><li name="450b" id="450b" class="graf graf--li graf-after--p graf--trailing"><a href="https://github.com/apple/swift/tree/master/docs" data-href="https://github.com/apple/swift/tree/master/docs" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">https://github.com/apple/swift/tree/master/docs</a></li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@nishantnitb" class="p-author h-card">Nishant Sharma</a> on <a href="https://medium.com/p/1e5dd5426064"><time class="dt-published" datetime="2018-12-31T05:25:17.314Z">December 31, 2018</time></a>.</p><p><a href="https://medium.com/@nishantnitb/writing-high-performance-swift-code-1e5dd5426064" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 11, 2021.</p></footer></article></body></html>