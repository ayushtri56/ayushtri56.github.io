<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Top IOS Interview Questions and Answers (April 2019) Part IV</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Top IOS Interview Questions and Answers (April 2019) Part IV</h1>
</header>
<section data-field="subtitle" class="p-summary">
Previous: Top IOS Interview Questions and Answers (April 2019) Part III
</section>
<section data-field="body" class="e-content">
<section name="dfee" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="6aab" id="6aab" class="graf graf--h3 graf--leading graf--title">Top IOS Interview Questions and Answers (April 2019) Part IV</h3><p name="0fbf" id="0fbf" class="graf graf--p graf-after--h3">Previous: <a href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-and-answers-april-2019-part-iii-70b28f5424a2" data-href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-and-answers-april-2019-part-iii-70b28f5424a2" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">Top IOS Interview Questions and Answers (April 2019) Part III</strong></a></p><p name="d8b7" id="d8b7" class="graf graf--p graf-after--p">Next: <a href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-and-answers-may-2019-part-i-174f3d24816" data-href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-and-answers-may-2019-part-i-174f3d24816" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">Top IOS Interview Questions and Answers (May 2019) Part I</strong></a></p><p name="d896" id="d896" class="graf graf--p graf-after--p">For more: <a href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-you-must-prepare-in-2018-e0d73be27adc" data-href="https://medium.com/ios-expert-series-or-interview-series/top-ios-interview-questions-you-must-prepare-in-2018-e0d73be27adc" class="markup--anchor markup--p-anchor" target="_blank"><strong class="markup--strong markup--p-strong">Top IOS Interview Questions and Answers for 2019</strong></a></p><h4 name="f809" id="f809" class="graf graf--h4 graf-after--p">Blocks</h4><p name="3362" id="3362" class="graf graf--p graf-after--h4">A block may capture values from local variables; when this occurs, memory must be dynamically allocated. The initial allocation is done on the stack, but the runtime provides a <code class="markup--code markup--p-code">Block_copy</code> function which, given a block pointer, either copies the underlying block object to the heap, setting its reference count to 1 and returning the new block pointer, or (if the block object is already on the heap) increases its reference count by 1. The paired function is<code class="markup--code markup--p-code">Block_release</code>, which decreases the reference count by 1 and destroys the object if the count reaches zero and is on the heap.</p><h4 name="33fe" id="33fe" class="graf graf--h4 graf-after--p">Property declarations</h4><ul class="postList"><li name="44dd" id="44dd" class="graf graf--li graf-after--h4"><code class="markup--code markup--li-code">assign</code> implies <code class="markup--code markup--li-code">__unsafe_unretained</code> ownership.</li><li name="1e4d" id="1e4d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">copy</code> implies <code class="markup--code markup--li-code">__strong</code> ownership, as well as the usual behavior of copy semantics on the setter.</li><li name="a3d3" id="a3d3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">retain</code> implies <code class="markup--code markup--li-code">__strong</code> ownership.</li><li name="d29e" id="d29e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">strong</code> implies <code class="markup--code markup--li-code">__strong</code> ownership.</li><li name="c2b1" id="c2b1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">unsafe_unretained</code> implies <code class="markup--code markup--li-code">__unsafe_unretained</code> ownership.</li><li name="d744" id="d744" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">weak</code> implies <code class="markup--code markup--li-code">__weak</code> ownership.</li></ul><h4 name="44ab" id="44ab" class="graf graf--h4 graf-after--li"><code class="markup--code markup--h4-code">@autoreleasepool</code></h4><p name="c862" id="c862" class="graf graf--p graf-after--h4">To simplify the use of autorelease pools, and to bring them under the control of the compiler, a new kind of statement is available in Objective-C. It is written <code class="markup--code markup--p-code">@autoreleasepool</code> followed by a <em class="markup--em markup--p-em">compound-statement</em>, i.e. by a new scope delimited by curly braces. Upon entry to this block, the current state of the autorelease pool is captured. When the block is exited normally, whether by fallthrough or directed control flow (such as <code class="markup--code markup--p-code">return</code> or <code class="markup--code markup--p-code">break</code>), the autorelease pool is restored to the saved state, releasing all the objects in it. When the block is exited with an exception, the pool is not drained.</p><p name="4dce" id="4dce" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">@autoreleasepool</code> may be used in non-ARC translation units, with equivalent semantics.</p><h4 name="4a35" id="4a35" class="graf graf--h4 graf-after--p">Method Swizzling</h4><p name="1890" id="1890" class="graf graf--p graf-after--h4">Sometimes for convenience, sometimes to work around a bug in a framework, or sometimes because there’s just no other way, you need to modify the behavior of an existing class’s methods. Method swizzling lets you swap the implementations of two methods, essentially overriding an existing method with your own while keeping the original around.</p><figure name="3c3b" id="3c3b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OKuxJoa7VYr7UlbRY-8XSQ.png" data-width="1445" data-height="774" src="https://cdn-images-1.medium.com/max/800/1*OKuxJoa7VYr7UlbRY-8XSQ.png"></figure><h3 name="2859" id="2859" class="graf graf--h3 graf-after--figure"><em class="markup--em markup--h3-em">Objective-C vs Swift comparison</em></h3><h4 name="a2b3" id="a2b3" class="graf graf--h4 graf-after--h3">Objective-C uses the runtime code compilation</h4><p name="79f4" id="79f4" class="graf graf--p graf-after--h4">Objective-C isn’t a fast language. The main reason is that it uses the runtime code compilation, rather than the compile time. This means that when the Objective-C object calls for another object in the code, there is an extra level of indirection involved. Generally, this happens very fast but when the code compilation happens a significant number of times, it becomes measurable. Objective-C is a superset of C and all C functions that you will write in Objective-C will be just as fast. Developers who write the performance-sensitive code often go back to clear C for those inner loops.</p><h4 name="81f1" id="81f1" class="graf graf--h4 graf-after--p">Safety</h4><p name="8dc8" id="8dc8" class="graf graf--p graf-after--h4">Swift was designed to improve the code safety for iOS products. It was created as a type-safe and memory-safe language. Type safety means that the language itself prevents type errors. The importance of type memory safety is that it helps avoid vulnerabilities associated with dangling or uninitialized pointers. These types of errors are the most common in development and difficult to find and debug. These advantages of the Swift language make it more attractive.</p><h4 name="ca47" id="ca47" class="graf graf--h4 graf-after--p">Maintenance</h4><p name="8983" id="8983" class="graf graf--p graf-after--h4">Managing files in Objective-C is a frustrating process because developers must manage two separate files. While Swift requires less maintenance and doesn’t require you to manage two files. The thing is that Swift automatically completes the reliances and performs an incremental build in the file.</p><h4 name="ab73" id="ab73" class="graf graf--h4 graf-after--p">Memory management</h4><p name="4cd1" id="4cd1" class="graf graf--p graf-after--h4">Objective-C language supports the Automatic Reference Counting (ARC) inside of the object-oriented code itself. The issue is that it cannot access C code and other APIs as Core Graphics. On the contrary, Swift is more consolidated, and its ARC is complete for procedural and object-oriented paths. Due to this fact, huge leaks of memory with the Swift language are impossible.</p><figure name="9da9" id="9da9" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*hR9wHQ0ogTlCUBqu22aAvQ.png" data-width="781" data-height="949" src="https://cdn-images-1.medium.com/max/800/1*hR9wHQ0ogTlCUBqu22aAvQ.png"></figure><h3 name="cc6e" id="cc6e" class="graf graf--h3 graf-after--figure">Difference between block (Objective C) and closure (Swift)</h3><p name="71f8" id="71f8" class="graf graf--p graf-after--h3">Swift closures and Objective-C blocks are compatible, so you can pass Swift closures to Objective-C methods that expect blocks. Swift closures and functions have the same type, so you can even pass the name of a Swift function.</p><p name="b530" id="b530" class="graf graf--p graf-after--p">Closures have similar capture semantics as blocks but differ in one key way: Variables are mutable rather than copied. In other words, the behavior of __block in Objective-C is the default behavior for variables in Swift.</p><h3 name="274b" id="274b" class="graf graf--h3 graf-after--p">Associated Types</h3><p name="2f5a" id="2f5a" class="graf graf--p graf-after--h3">An <em class="markup--em markup--p-em">associated type</em> gives a placeholder name to a type that is used as part of the protocol. The actual type to use for that associated type isn’t specified until the protocol is adopted. Associated types are specified with the <code class="markup--code markup--p-code">associatedtype</code>keyword.</p><p name="8c94" id="8c94" class="graf graf--p graf-after--p">protocol Container {<br> <strong class="markup--strong markup--p-strong">associatedtype</strong> Item<br>mutating func append(_ item: Item)<br>var count: Int { get }<br>subscript(i: Int) -&gt; Item { get }<br>}</p><figure name="9e15" id="9e15" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*OO0S5Wm-lD9P_PW3MrG7ug.png" data-width="403" data-height="492" src="https://cdn-images-1.medium.com/max/800/1*OO0S5Wm-lD9P_PW3MrG7ug.png"></figure><p name="b811" id="b811" class="graf graf--p graf-after--figure">The definition of <code class="markup--code markup--p-code">typealias Item = Int</code> turns the abstract type of <code class="markup--code markup--p-code">Item</code> into a concrete type of <code class="markup--code markup--p-code">Int</code> for this implementation of the <code class="markup--code markup--p-code">Container</code> protocol.</p><p name="13ad" id="13ad" class="graf graf--p graf-after--p">Thanks to Swift’s type inference, you don’t actually need to declare a concrete <code class="markup--code markup--p-code">Item</code> of <code class="markup--code markup--p-code">Int</code>as part of the definition of <code class="markup--code markup--p-code">conformingClass.</code></p><h3 name="4390" id="4390" class="graf graf--h3 graf-after--p">Hope you like it , Go to <a href="https://medium.com/ios-expert-series-or-interview-series" data-href="https://medium.com/ios-expert-series-or-interview-series" class="markup--anchor markup--h3-anchor" target="_blank">iOS interview questions 2018 series</a></h3><p name="490f" id="490f" class="graf graf--p graf-after--h3">References:</p><ol class="postList"><li name="5313" id="5313" class="graf graf--li graf-after--p graf--trailing"><a href="https://www.altexsoft.com/blog/engineering/swift-vs-objective-c-out-with-the-old-in-with-the-new/" data-href="https://www.altexsoft.com/blog/engineering/swift-vs-objective-c-out-with-the-old-in-with-the-new/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">https://www.altexsoft.com/blog/engineering/swift-vs-objective-c-out-with-the-old-in-with-the-new/</a></li></ol></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@nishantnitb" class="p-author h-card">Nishant Sharma</a> on <a href="https://medium.com/p/7e48a0d13be0"><time class="dt-published" datetime="2019-04-25T16:03:29.531Z">April 25, 2019</time></a>.</p><p><a href="https://medium.com/@nishantnitb/top-ios-interview-questions-and-answers-april-2019-part-iv-7e48a0d13be0" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on February 11, 2021.</p></footer></article></body></html>